############################## UNKLARHEITEN UND FRAGEN ##############################

ICH DACHTE ES WÄRE ALLES QUATSCH WAS ICH MACHE - stimmt aber so nicht! HAH!

(jetzt beispiel zeigen mit A, B, C, D und R zeigen)

ich kann ja auf die die kodierten packete aufbauen. Also jeder schickt ein packet und niemand hat plan von den jeweiligen packeten außer seinem packet selber, also können zuerst nur zwei packete verschickt werden. 
Jetzt haben tatsächlich schon zwei peers jeweils zwei packete (angenommen die konnten das dekodieren) und darauf kann eine coding opportunity mit drei packeten gebildet werden. Im nächsten dann vier!
Es wird davon ausgegangen, dass das vorherige dekoding erfolgreich war und darauf basierend eine noch bessere Coding opportunity gefunden. Das wichtige dabei ist, dass dem relay node nicht die packete in der virtual queue ausgehen und der dann nicht
doch wieder zwei packete zusammen kodiert.


PACKETE ACKN?

Nachdem jeder peer seinen reception report geschickt hat, wird die ack queue gelaufen und geschaut, welche packete der peerr nicht bekommen hat.
   - problem ist hier, dass kodierte packete noch in der queue stecken, und der relay node dann packete rescheduled, die der peer schon hat. 
Bei einer retransmission werden die packete wieder in die virtual queue gelegt. 
- Hier kann auch das Problem auftreten, dass packete als aked angenommen werden durch die false positives - damit werden die dann gelöscht. 
  Ein Lösungsansatz wäre vielleicht, negativ zu acken. Also nur dem relay node zu schicken welche packete fehlen. Ein flase positive würde dann nur zu einer erneuten retransmission führen.
  Eigentlich ein interessantes konzept.

GARBAGE COLLECTION & PACKET POOL HASHMAP

Momentane Lösung:

siehe BA arbeit - wird dort sehr gut beschrieben

"OPPORTUNISTIC" FEHLT NOCH

So wie es im moment läuft, ist der maximale goding gain 2, da keine packete gesnooped werden und sich nie eine coding möglichkeit von mehr als zwei packeten ergibt.
Ich weiß nicht, ob ESP NOW im promiscoius mode funktioniert. Selbst wenn ich das hinkriege, dann müsste ich einen packet filter einbauen und aktiv packete überhören, 
da alle peers in radio range sind und jeder dann direkt alle nativen packete mitkriegen und das coding dann sinnlos ist. Wenn ich jetzt die nodes auseinander ziehe und hidden nodes
erzeuge, dann funktioniert mein synchronisations schema nicht mehr (in dem wird der ällteste node über broadcasts gesucht).

Es ist in dem sinne "opportunistisch", dass der relay node beim senden eines kodierten packetes davon ausgeht, dass alle peers dieses packet dekodieren können.
das nächste kodieren darauf aufbaut. Über die erhaltenen reception reports können dann (wie in der ersten Frage beschrieben) die packete geacked werden und eventuell neu kodiert werden.    

Du meintest ja, dass ich sowie so nur das Alice und Bob Beispiel machen soll aber wäre iregdnwie schon cool ein höheren coding gain als 2 zu bekommen...


NUTZEN DES BLOOMFILTER

Die Größe des Bloomfilters ist jetzt variabel und ich habe die minimum anzahl der packet in einem reception report berechnet, ab die der bloomfilter weniger "kostet" als ein herkömmlicher reception report.

Man ACKed mit dem bloom filter nur die letzten erhaltenen Packete
Der relay node für pro peer eine ackliste, in der die packete stehen, welche erfolgreich dekodiert wurden und diese dann als Bloomfilter dann dem Relay schicken. 


CODING GAIN MAXIMIEREN

Jetzt ist es ja so, dass ich den Coding Gain "richtig" berechnen kann - also wieviele Bits benötigt werden um zu Codieren im Verhältnis zum echten Intformationsgehalt.
Ich das meiste and Bits wird dabei der Bloomfilter nehmen, denn der ist ziemlich Groß um die Wkt für False Positives zu minimieren. Das ist vielleicht nicht mal wirklich effizient.
Da ich dadurch vielleicht sogar die Coding Bilanz runterziehe, also ich nehme flasches Coding in kauf, dafür dass ich kürzere Reception Reports schicke. 
Wie kann ich jetzt die optimale Länge des Bloomfilters finden, um den Coding Gain zu maximieren?

Problem: Ein native peer acked nur packete die er erfolgreich dekodiert hat. Packete die er selbst erstellt hat werden nicht geacked und damit auch nicht als "in reception report" getaggt und somit auch nicht garbage collected.
         Somit läuft der pool irgendwann voll.

WIE KANN ICH MEIN SYSTEM AM BESTEN AUSWERTEN

Was soll ich denn darstellen? Ich könnte den Coding gain mit der Zeit plotten. Aber den kenne ich ja und kann ja theoretisch bewiesen werden. Im Coding gain sind ausßerdem nicht die Reception reports mit drinne, die das 
ganze ja "ineffizienter" machen. Gibt es sowas wie ein Verhältnis aus Nutzbaren Bits und für Bits zur Umsetzung? Ich denke, das ist das nächst beste, was ich aufstellen kann um auf eine positive energieeffizienz 
gegenüber herkömmlichen fooding algorithmen zu schließen. Ich kann ja schlecht den genauen Energieverbrauch mit anderen Netzwerken vergleichen. 


SEQUENZ NUMMERN UND WAHRSCHEINLICHKEIT

Wie berechne ich die wahrscheinlichkeit, dass mindestens zwei gleiche sequenz nummern für n tranmissions vorkommen?
   - das ist ein statstischen rabbit hole - ich glaube man kann das mit dem birthday paradox berechnen P(n) = 1 - (N! / (N-n)!N^n)

VORTEILE MEINER ARCHITECKTUR

Packete werden automatisch in das netzwerk verteilt über den relay node. Es ist super einfach das System so anzupassen, dass wenn der Relay node ausfällt, einfach der nächste peer in der list weiter macht.
Die nodes könnten zum beispiel einen timer für eine bestimmte Zeit setzem, in in der sie ein coded packet bekommen müssen. Läuft dieser Timer ab, dann gehen die Nodes davon aus, dass der Raly node ausgefallen ist und es wird der Nächste peer als relay node ausgewählt.
Das ist möglich, da die peers zu beginn der neighbor detection phase eine liste aller peers sortiert nach ihrer mac addressen erstellt haben. 


PACKETE WERDEN GELÖSCHT UND DANN BEI LOOKUP NICHT GEFUNDEN

ich glaube es liegt daran:

Die reception reports werden basierend auf der anzahl der erfolgreichen kodierungen gesendet. Also für sagen wir 10 dekodierungen wird ein reception report gesendet.
Der relay node löscht alle packete, welche von allen peers acknowledged werden.

Wenn jetzt eine dekodierung bei einem Peer fehlschlägt ist der reception report in verzug. 


AUSFALLEN EINES PEERS

Wenn irgend ein peer ausfällt dann scheitert das ganze netzwerk für eine Phase:

   Lösung zum ausfall des relay nodes:
      Wenn der relay node ausfällt, könnte man das umgehen in dem jeder peer einer timer stellt. Bevor ablauf des timers muss der peer ein kodiertes packet erhalten, sonst wird davon ausgegangen, dass der relay node ausgefallen ist.
      Dann wird einfach der nächste peer in der Liste als relay node ausgewählt. Alle peers haben die gleiche liste ( wenn in radio range) und die ist nach mac addressen sortiert. Es werden also alle peers den slebn neune  relay node wählen.
      Dann schicken alle einfach nochmal einen reception report an den peer und der kann dann darauf basierend weiter kodieren.

   Lösung zum ausfall eines peers:
      Gleiches gilt für den relay node. 
      Er stellt einen Timer für den peer, nachdem er ein native packet bekommen hat. Innderhalb dieser Zeit muss ein neues native packet vom gleichen peer eintreffen.
      Ist das nicht der Fall, dann löscht er den Peer aus seiner liste und bezieht in nicht mit ein.

   So kommt es nicht zum vollen ausfall einer message exchange phase. Ich denke das werde ich nicht implementieren aber das wäre der Lösungsansatz.
   So wie es jetzt ist, fällt halt die message exchange phase dann aus und in der nöchsten Phase werden die peerlist neu befüllt und der ausgefallene peer wird nicht einbezogen.
   Nicht ideal aber funktioniert. 
